# 모듈과 IIFE

## 배경
옛날 옛적? ES6도 없었을 무렵에는 var만 사용할 수 있었다. 그런데 var의 스코프는 블록 레벨 수준이 아니고 개발자들은 var도 블록 레벨 스코프를 가질 수 있게 여러가지 방안을 고려하게 되었다.   
이때 만들어진 것이 IIFE인데  
IIFE란 Immediately Invoked Function Expression (즉시 실행되는 함수 표현식) 의 약자로 정의와 동시에 즉시 실행되는 함수를 의미한다.  

```
// 함수를 선언과 동시에 실행한다.  
function() { // <-- Error: Function statements require a function name
  let message = "Hello";
  alert(message); // Hello
}();
```

IIFE를 사용하게 되면 가장 바깥에 변수를 선언하더라도 함수로 감싸져 있기 때문에 전역에 변수를 선언하지 않고 캡슐화하할 수 있게 된다.  
그러한 이유로 IIFES는 보편적으로 한 번의 실행만 필요로 하는 초기화 코드 부분에 많이 사용되며 전역 스코프를 오염시키지 않기 위해 사용하는 경우가 많다.  

### 전역 변수의 문제점
[전역변수의 문제점](../../Book_Review/ModernJS_DeepDive/14%20전역%20변수의%20문제점/README.MD)  
대단한 모던 자바스크립트 DEEP DIVE 책에서 잘 설명해준다.   
요약하자면   
1. 내 의도와는 다르게 어디서든지 전역변수를 참조 및 변경이 가능하다.
2. 생명주기가 프로그램의 종료시점과 거의 일치하므로, 이는 상태 변경기회를 늘리게 되며 메모리에도 게속 상주하게 되는 것이므로 리소스도 오랜 기간 소비한다.
3. 스코프 체인 상에서 종점에 존재하므로 전역변수의 검색 속도가 가장 느리다.
4. JS의 가장 큰 문제는 .js 파일이 분리되어 있어도 하나의 전역 스코프를 공유한다는 것인데 .js 파일을 나누어 협업을 진행하게 될 경우 전역 변수 이름으로 충돌이 생길 확률이 매우 높다.

이러한 이유로 전역 변수의 사용을 최대한 줄이기 위해 자바스크립트는 많은 방법을 고안했는데 그 방법 중 하나가 모듈화이다. (let, const도 그 해결법으로써 탄생했다.)

## 모듈이란?
모듈이란 여러 기능들에 관한 코드가 모여있는 하나의 파일 로 다음과 같은 것들을 위해 사용한다.  
- 유지보수성 : 기능들이 모듈화가 잘 되어있다면, 의존성을 그만큼 줄일 수 있기 때문에 어떤 기능을 개선한다거나 수정할 때 훨씬 편하게 할 수 있다.
- 네임스페이스화 : 자바스크립트에서 전역변수는 전역공간을 가지기 때문에 코드의 양이 많아질수록 겹치는 네임스페이스가 많아질 수 있다. 그러나 모듈로 분리하면 모듈만의 네임스페이스를 갖기 때문에 그 문제가 해결된다.
- 재사용성 : 똑같은 코드를 반복하지 않고 모듈로 분리시켜서 필요할 때마다 사용할 수 있다.

## 모듈의 역사

### CommonJS
- 가장 처음 등장한 자바스크립트의 모듈화 방법으로 다른 모듈을 사용할 때는 require 를, 모듈을 해당 스코프 밖으로 보낼 때에는 module.exports 를 사용하는 방식이다.
- Node.js에선 현재 이 방식을 사용하고 있다...(아 import export를 안쓰는구나..?)
- module.exports 의 module 은 현재 모듈에 대한 정보를 갖고 있는 객체이다.
- require의 동작은 먼저 파라미터로 받은 경로값에 위치한 파일을 불러오고, module이라는 예약어가 해당 모듈 파일에 module이라는 빈 객체를 만들게 된다. 
- 이 빈 객체에서 js파일을 즉시 실행 함수로 둘러친 뒤, 이를 바로 실행시키고 module.exports를 리턴하는 방식이 require의 모듈 방식이다.
> #### 이 방식은 예전 방식이고 현재는 내부 모듈 시스템에 의해 알아서 캡슐화가 된다고 한다!)

#### 이렇게 IIFE의 캡슐화 원리가 require메서드에서도 그대로 쓰이는데 보호하고자 하는 api들을 즉시실행함수로 둘러싸 외부의 접근을 막고, 접근 가능한 object들을 리턴하여 사용할 수 있게 한다.

## AMD(Asynchronous Module Definition)
- CommonJS가 서버쪽에서 장점이 많은 반면에 AMD는 브라우저 쪽에서 더 큰 효과를 발휘한다. 브라우저에서는 모든 모듈이 다 로딩될 때까지 기다릴 수 없기 때문에 비동기 모듈 로딩방식으로 구현을 해놓았다. 
> 본적이 없고 서버에서 사용하지 않으니 넘어가자

## UMD(Universal Module Definition)
- 모듈 구현방식이 CommonJS 와 AMD로 나뉘기 때문에 그걸 통합하기 위한 하나의 패턴이라고 할 수 있다.
- AMD, CommonJS, Browser 3가지 방식의 모듈을 지원할 수 있다.

## ES6(ES2015) 방식
- import 와 export 구문을 사용하는 방식
- 하지만 모든 브라우저가 지원하는 것이 아니기 때문에 Babel을 사용해야 한다.
> 지금 깨달았는데 서버쪽 개발자분들 코드가 꽤 require를 사용하는게 많았는데 애초에 바벨이나 es6방식을 사용하지 않는 것으로 서버사이드는 정착한것 같다고 생각이 든다.  
> 그 이유도 추측인데 linux환경에서도 바벨과 es6를 지원하기 위해 생기는 에러와 환경 개발자들의 수고가 안쓰는 방식이 편하다고 생각되어서인것 같다?  
> 추후 좀 더 알아볼 예정이다.

- default export는 모듈 내에서 한번만 사용될 수 있고 named export는 여러번 사용할 수 있다.
- named export로 내보내면 {} 로 묶어서 불러와야 한다. 이것이 기본적인 사용법이고 별칭(alias)을 as 로 주어서 다른 이름으로 사용할 수도 있고 * 와일드카드를 사용하여 한번에 불러오거나 내보낼 수도 있다.  
> airbnb eslint를 사용하며 프로젝트를 진행하였는데 eslint에서는 named export를 권장하지 않는다고 한다. 그럼 모든 내보내야 할 js 파일을 각각 모듈화해야 하느냐 라는 의문이 드는데 또 단일 책임 원칙을 개발에 있어 중점적으로 생각해보면 그게 맞는것 같다는 생각이 든다  
> Prefer default export.eslint(import/prefer-default-export)  
> 이런식으로 eslint 경고메세지가 뜬다.  

## 결론
- 스스로 생각해서 만든 결론이라서 더 알아볼 필요가 있다.
- react 등의 프론트엔드에서는 es6 모듈을 권장한다. 다만 바벨이나 웹팩 등의 작업을 거칠 필요가 있다.
- nodejs 백엔드에서는 CommonJS 모듈을 권장한다. 환경이 조금 더 한정적인 프론트엔드보다 더 다양한 환경과 모듈 개수때문에 이름에 맞게 가장 common한 모듈 방식을 택한듯 싶다.

> 출처:  
> https://baeharam.netlify.app/posts/javascript/module

