# session을 db에 저장하는 이유

> 이것저것 하다 보니 잘 모르겠는 코드를 발견했다.  
```
app.use(
  session({
    store: MongoStore.create({ mongoUrl: process.env.DB_URL }),
  })
);
```  
> 아예 모르고 접근해서 처음에는 db의 데이터를 세션 저장소에 넣는건 줄 알고 왜??? 하면서 주의깊게 살펴봤던 것 같다.  
> 결론은 세션 데이터를 db에 저장한다는 게 이 코드의 핵심인데 찾아보니 이것도 나름 여러 시행착오와 이유를 거쳐서 이렇게 된 것 같아서 자세히 알아보게 되었다.

## sesstion이란
> - 모든 웹 서비스는 http 통신을 기본으로 하고 있다. 그러나 http는 기본적으로 stateless 특성을 갖는다. 즉, 누구도 상태를 유지하지 않는다
> - 상태를 유지 하지 않으면 사용자가 온라인 구매 사이트에 접속하여 물품을 장바구니에 넣어놓고 다음날 다시 접속해서 확인하니 장바구니에 물품이 없는 상황이 발생하게 된다.
- 위와 같은 상황이 발생하기 때문에 상태 유지를 위한 statefull 을 지원하기 위해 Session 개념이 생겨났다.

### 쿠키(cookie)와의 차이점
- 쿠키 또한 Connectionless, Stateless의 성격을 가진 HTTP의 단점을 해결하기 위해 생겨났다.
- 쿠키는 웹 서버가 브라우저에게 지시하여 사용자의 로컬 컴퓨터에 파일 또는 메모리에 저장하는 작은 기록 정보 파일이며, **보안에 취약하고**, 파일에 담긴 정보를 인터넷 사용자가 같은 웹사이트를 방문할 때마다 읽히고 수시로 **새로운 정보로 바뀔 수 있기 때문에** 중요한 정보를 담아두지 않는 단지 토큰으로 쓰인다.
- 또한 쿠키에 대한 정보를 매 헤더(Http Header)에 추가하여 보내기 때문에 상당한 트래픽을 발생시킨다.
- 클라이언트에 300개까지 쿠키저장 가능, 하나의 도메인당 20개의 값만 가질 수 있음, 하나의 쿠키값은 4KB까지 저장가능하기 때문에 저장 용량 초과 문제가 생긴다.

#### 이 때문에 쿠키의 트래픽 문제와 쿠키를 변경하는 보안적 이슈를 해결하는 세션이 등장하였다.
- 세션은 HTTP Session id를 식별자로 구별한 후 데이터를 사용자의 브라우저에 쿠키형태로 저장하는 것이 아닌 접속한 **서버에** 정보를 저장한다.
- 클라이언트는 HTTP Session id를 쿠키로 메모리 저장된 형태로 가지고 있다.
- 메모리에 저장하기 때문에 브라우저가 종료되면 사라지게 된다.

### 세션의 작동 방식
1. 클라이언트가 서버에 Resource를 요청한다.
2. 서버에서는 HTTP Request를 통해 쿠키에서 Session id를 확인을 한 후에 없으면 Set-Cookie를 통해 새로 발행한 Session-id를 클라이언트에 보낸다.
3. 클라이언트는 HTTP Request 헤더에 Session id를 포함하여 원하는 Resource를 요청을 한다.
4. 서버는 Session id를 통해 해당 세션을 찾아 클라이언트 상태 정보를 유지하며 적절한 응답을 한다.
> - 즉 쿠키는 클라이언트가 세션에 접속하기 위한 키로써 작용한다.

### 세션의 장점
- 서버에 저장하기 때문에 매우 관리하기 편하고 효율적
- cookie와 달리 사용자의 정보를 외부에서 조작하기 힘들기 때문에 쿠키보다 중요한 정보를 담을 수 있게 된다.
- 즉 세션에는 기밀성, 무결성, 확실성이 보장된다.(보장되어야 한다.)

### 세션의 단점
- 쿠키에 비해 데이터 양이 많기 때문에 서버 저장공간이 커지게 된다.
- 따라서 세션 저장 장치가 부족한 시스템에는 적합하지 않다.
- 이후 나오게 될 로드밸런서를 통한 부하분산 상태에서 다루기가 어렵다.

## 세션의 저장방식
Session의 저장 방식은 3가지로 나눌 수 있다. 순서대로 이전의 저장방식의 문제점을 보완하게 되어 최종적으로 db에 저장하는 방식이 되었다. 
1. In memory
  - app 을 구동하고 있는 서버의 메모리에 Session을 생성한다.
2. File storage
  - app 을 구동하고 있는 서버의 특정 디렉토리에 파일 형태로 Session을 생성한다.
3. Database storage
  - file storage 대신에 DB 에 저장한다.

### 1. In memory
- 세션의 작동 방식대로 작동한다. 단 db가 아니라 메모리에 저장된다.

#### 문제점
- app이 오류가 발생해서 죽었을 때 app을 재접속하게 된다. 이 때 Cookie는 그대로이지만 서버의 Session이 변경된다. 
- app 을 재시작하면서 메모리는 휘발성이기 때문에 메모리에 저장된 Session은 모두 초기화 되는 것이다. 따라서 Cookie는 동일하지만 메모리에 Session이 사라졌기 때문에 Session을 재생성하게 되어 임의의 사용자가 무엇을 했는지에 대한 정보가 손실된다.
- 또한 메모리 용량의 문제도 존재한다. 사용자가 급격히 증가하면, Session이 차지하는 메모리는 증가하고 용량 app 은 시스템 메모리 초과로 인해 죽게 된다.
### 2. File storage
- memory의 문제점을 해결하여 휘발되지도 않고, 저장 용량도 충분한 파일형태로 Session을 저장한다.

#### 문제점
- 사용자의 급증으로 서버를 추가로 늘렸다. 사용자는 로드밸런서에 의해 분할되어 접속된다.
![image](https://devhaks.github.io/2019/04/20/session-strategy/example1.png)  
- 서버를 늘리기 전에 사용자는 온라인 사이트에 물품을 장바구니에 넣고 서버의 Session 파일에는 사용자의 장바구니 정보가 저장되어 있다.
- 그런데 서버를 늘린 후에 사용자는 자신의 장바구니의 물품이 사라졌다.
- 원인은 새로운 서버에 사용자의 Session 파일이 없기 때문이다.
![image](https://devhaks.github.io/2019/04/20/session-strategy/example3.png)  
- 이와 같은 문제도 존재한다.
- 실제 동일한 사용자이지만 여러 디바이스를 통해 접속 하므로 각각의 디바이스 마다 Session과 Cookie가 다르게 생성되는 경우에도 데이터의 유지가 힘들다.

### 3. Database storage
- 위와 같은 문제로 인해 사용자 정보가 담긴 세션은 db로 저장되게 되었다.
- 그러나 그렇게 된다면 바로 db로 넣는 것이 사용자 정보를 세션에 넣어 db로 넣는 것 보다 나은데 왜 굳이 session을 저장하게 되었을까?

#### 세션의 역할
- 세션은 이미 만들어져 사용자의 활동을 저장하기 쉬운 것과 더불어 사용자의 로그인 유지를 만료시키는 시간을 설정해주기도 한다.
- 즉 사용자가 만료되지 않은 sessionToken을 가지고 있다면 사용자는 어떤 디바이스로 접속하던 만료기간 전이라면 recode를 생성하여 자동으로 로그인 되어있고 사용자의 세션에 입력된 만료기간이 지나면 자동으로 로그아웃된다. 

## 결론
- 세션은 사용자의 활동 정보를 Stateless한 http에서 상태를 유지한다는 점에서 쿠키와 비슷하지만 보안적인 이유로 정보가 없거나 최소한으로 주는 쿠키보다 중요한 정보를 담고 있다.
- 그러나 결국 데이터 유지를 매우 큰 트래픽에서 사용하기 위해서는 db에 저장해야 하는데 바로 db에 저장하지 않고 세션을 db에 저장시키는 방식이 아직 사용되고 있다.
- 그 이유는 사용자의 로그인 정보를 만료시키는 세션의 역할이 있기 때문이다.

> 출처:   
> https://devhaks.github.io/2019/04/20/session-strategy/  
> https://stackoverflow.com/questions/33897276/what-is-the-difference-between-a-session-store-and-database  
> https://millo-l.github.io/Nodejs-express-session-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/
> https://nesoy.github.io/articles/2017-03/Session-Cookie






