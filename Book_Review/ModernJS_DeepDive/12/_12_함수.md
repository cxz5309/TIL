# 12 함수

## 12.1 함수란?
- 일련의 과정을 문(statement)으로 구현하고 코드 블록으로 감싸 하나의 실행 단위로 정의한 것.
  
### 매개변수
- 함수 내부로 입력을 전달받는 변수
### 인수
- 입력
### 반환값
- 출력

### 함수 정의
- 함수를 생성하는 방법
- 다양한 방법이 있음

### 함수 호출
- 인수를 매개변수를 통해 함수에 전달하면서 함수의 실행을 명시적으로 지시, 코드블록에 담긴 문들이 일괄적으로 실행 후 반환값을 반환

## 12.2 함수를 사용하는 이유
- 코드의 재사용
  - 코드의 중복 억제
  - 유지보수의 편의성
  - 코드의 신뢰성
- 코드의 가독성

## 12.3 함수 리터럴

함수는 객체 타입의 값이다.
따라서 함수도 함수 리터럴로 생성할 수 있다.

### 함수 리터럴의 구성요소
- 함수 이름
  - 식별자이므로 식별자 네이밍 규칙이 있음
  - **함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다**
  - 생략 가능 기명 함수/무명,익명 함수로 나뉜다
- 매개변수 목록
  - 순서에 의미가 있다.
  - 함수 몸체 내에서 변수와 동일하게 취급되므로 식별자 네이밍 규칙을 준수해야 한다.
- 함수 몸체
  - 함수 호출에 의해 실행

> 식별자 네이밍 규칙
> - 식별자는 특수문자를 제외한 문자,숫자,언더스코어(_),달러 기호($)를 포함할 수 있다.
> - 식별자는 특수문자를 제외한 문자,언더스코어,달러 기호로 시작해야한다. 숫자로 시작하는것은 허용하지 않는다.
> - 예약어는 식별자로 사용할 수 없다.

### 일반 객체와의 차이점
- 일반 객체는 호출할 수 없지만 함수는 호출할 수 있다.

## 12.4 함수 정의

- 함수 선언문 
```
function add(x, y){
    return x + y;
}
```
- 함수 표현식
```
const add = function (x, y){
    return x + y;
};
```
- function 생성자 함수
```
const add = new Function('x','y','return x + y');
```
- 화살표 함수
```
const add = (x, y) => x + y;
```

### 변수 선언과 함수 정의
변수 선언 : 변수 선언문이 평가되면 선언만 되었다고 한다. 하지만 실제로는 undefined가 할당되기 때문에 js에서는 선언과 정의의 구분이 모호하다.
함수 정의 : 함수 선언문이 평가되면 식별자가 암묵적으로 생성되고 함수 객체가 할당된다.

### 12.4.1 함수 선언문
- **함수 이름을 생략 불가**
- 표현식이 아닌 문이기 때문에 변수에 할당 불가
- 그러나 자바스크립트 문법은 {}를 코드 블록문과 객체 리터럴 양쪽으로 해석하여 문맥에 따라 바꾸어 주기 때문에 단독 사용과 피연산자로 사용하는 경우 양쪽 다 동작한다. 하지만 **내부 동작에 차이가 있다.**

그룹 연산자 내에 있는 함수 리터럴은 선언문이 아니라 함수 리터럴 표현식으로 해석된다.
```
(function bar() {console.log('bar');});
bar();// 레퍼런스 오류 발생
```
- 함수 선언문에서는 자바스크립트 엔진이 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당한다.
- **즉, 함수는 함수 이름으로 호출하는 것이 아니라 암묵적으로 생성한 식별자로 호출된다.**
```
function add(x, y){
    return x + y;
};
```
를 실행했을 때
```
var add = function add(x, y){
    return x + y;
};
```
가 실행된다.

> 5.6 표현식인 문과 표현식이 아닌 문
> - 표현식인 문
>   - 값으로 평가될 수 있는 문
> - 표현식이 아닌 문
>   - 없는 문

## 12.4.2 함수 표현식
### 1급 시민
- 변수에 담을 수 있다.
- 함수(혹은 메소드)의 인자(매개변수, Parameter)로 전달할 수 있다.
- 함수(혹은 메소드)의 반환값(return)으로 전달할 수 있다.
- 자바스크립트에서 원시 값(일반 자료형)은 1급 객체

### 1급 객체
- 1급 시민의 조건을 충족하는 객체(Object) 입니다. javascript에서 객체는 1급시민입니다. 
- 자바스크립트의 개체는 함수의 인자가 될 수 있다.
- 자바스크립트의 객체는 함수의 리턴이 될 수 있다.
- 자바스크립트의 객체는 변수에 할당 될 수 있다.
- var a = {msg: 'a는 1급 객체입니다.'} // 변수

### 1급 함수
- 1급 시민의 조건을 충족하는 객체(Object) 입니다. javascript에서 객체는 1급시민입니다. 
- 자바스크립트의 함수는 변수에 할당할 수 있다.
- 자바스크립트의 함수는 매개변수로 전달할 수 있다.
- 자바스크립트의 함수는, 함수를 반환할 수 있다.
1급 함수는 추가적인 조건을 요구한다.
- 런타임(runtime) 생성이 가능하다
- 익명(anonymous)으로 생성이 가능하다
  - 이런 추가조건으로 봤을 때 C의 함수는 1급 함수로 볼 수 없다.


### 함수 표현식
- 함수는 1급 객체이므로 함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있다.
- 함수 리터럴의 함수 이름은 생략할 수 있다.(일반적)
함수 호출시 함수이름이 아닌 함수 객체럴 가리키는 식별자를 사용해야 한다.

함수 선언문은 **표현식이 아닌 문** 이고 함수 표현식은 **표현식인 문** 이다.

### 12.4.3 함수 생성 시점과 함수 호이스팅

### 함수 호이스팅
- **함수 선언문으로 함수를 정의하면 런타임 이전에 함수 객체가 먼저 생성된다.**

### 함수 호이스팅과 변수 호이스팅의 차이
- var로 선언된 변수는 undefined로 초기화되고, 함수 선언문을 통해 암묵적으로 생성된 식별자는 함수 객체로 초기화된다.
- 즉, 함수 호이스팅으로 정의한 함수는 선언문 이전에 호출해도 호출이 가능하다.

**함수 표현식으로 함수를 정의하면 변수 호이스팅이 발생한다.**
\+ 변수 호이스팅이나 함수 호이스팅이나 권장되지 않으므로 함수 선언문 대신 함수 표현식을 사용할 필요가 있다.

### 12.4.4 Function 생성자 함수
- 객체를 생성하는 생성자 함수로 생성된 함수
- 일반적이지 않고 바람직하지도 않다.
- **클로저를 생성하지 않는** 등 함수 선언문과 함수 표현식과 다르게 동작한다.

### 12.4.5 화살표 함수
- 항상 익명 함수로 정의한다.
- 기존 함수보다 표현만 간략한 것이 아니라 내부 동작 또한 간략화되어 있다.
- **기존 함수와 this 바인딩 방식이 다르고**
- **protorype 프로퍼티가 없으며**
- **arguments 객체를 생성하지 않는다**

## 12.5 함수 호출

### 12.5.1 매개변수와 인수

### 매개변수
- 함수를 정의할 때 선언하며, 함수 몸체 내부에서 변수와 동일하게 취급된다.
- 일반 변수와 마찬가지로 undefined로 초기화된 이후 인수가 순서대로 할당된다.
- 매개변수의 스코프는 함수 내부다.
- 매개변수의 개수와 인수의 개수가 일치하는지 체크하지 않는데 **인수가 부족해서 인수가 할당되지 않은 매개변수의 값은 undefined이다.**, 초과된 인수는 무시된다.

### 12.5.2 인수 확인

- 자바스크립트는 인수의 개수를 확인하지 않으므로 필요한 경우 다른 방법으로 확인한다.
  - 타입스크립트 등 자바스크립트의 상위 확장 도입
  - arguments 객체를 통해 인수 개수를 확인
  - 인수가 전달되지 않은 경우(undefined) 단축 평가를 사용해 매개변수에 기본값을 할당.
  - ES6에서 도입된 매개변수 기본값을 사용하여 인수 체크 및 초기화를 간소화 

> arguments 객체  
> https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/arguments  
> arguments 객체는 Array가 아닙니다. Array와 비슷하지만, length 빼고는 pop()과 같은 어떤 Array 속성도 없습니다.   
> arguments.length : 함수에 전달된 인수의 수를 가리킵니다.  


### 12.5.3 매개변수의 최대 개수
- 많을수록 좋지 않다.
- 이상적인 함수는 한가지 일만 해야 하며 가급적 작게 만들어야 한다.

**함수 외부에서 함수 내부로 전달한 객체를 함수 내부에서 변경하면 함수 외부의 객체가 변경되는 부수효과가 발생한다**

### 12.5.4. 반환문
- 함수의 실행을 중단하고 함수 몸체를 빠져나간다.
- return 키워드 뒤에 오는 표현식을 평가해 반환한다.(명시적으로 지정하지 않으면 undefined가 반환된다.)
- 생략 가능(undefined)
- 줄바꿈시 세미콜론 자동 삽입 기능에 의해 다음줄 무시
- 함수 몸체 내부에서만 사용 가능

## 12.6 참조에 의한 전달과 외부 상태의 변경
**객체는 참조에 의한 전달 방식으로 동작한다. 함수는 객체이다**

### 매개변수로 원시 타입 인수가 전달될 경우
- **값이 깊은 복사되어 매개변수로 전달되기 때문에 원본은 훼손되지 않는다.**
### 매개변수로 객체 타입 인수가 전달될 경우
- **참조값이 복사되어 매개변수에 전달되기 때문에 원본이 훼손된다.**

### 해결방법
- 옵저버 패턴 등을 이용하여 객체의 참조를 공유하는 모든 이들에게 변경 사실을 통지하고 이에 대처하는 추가 대응이 필요하다.
- 객체를 깊은 복사를 통해 불변 객체로 만든다.

### 순수 함수
- 외부 상태를 변경하지 않고 외부 상태에 의존하지 않는 함수

## 12.7 다양한 함수의 형태

### 12.7.1 즉시 실행 함수
- 함수 정의와 동시에 즉시 호출되는 함수
- 단 한번만 호출되며 다시 호출할 수 없다.
- 반드시 그룹 연산자()로 감싸야 한다.
- 즉시 실행 함수도 일반 함수처럼 값을 반환하고 인수를 전달할 수 있다.
```
(function(a, b){
    return a + b;
}(3, 5));  
```
### 12.7.2 재귀 함수
- 재귀 호출을 수행하는 함수
- 함수 이름은 함수 몸체 내부에서만 유효하다 = 함수이름을 사용해 자기 자신을 호출할 수 있다.(함수 외부에서는 반드시 식별자)

### 12.7.3 중첩 함수(내부 함수)
- 함수 내부에 정의된 함수
- **외부 함수의 변수를 참조할 수 있다.**
- 일반적으로 자신을 포함하는 외부 함수를 돕는 헬퍼 함수의 역할을 한다.

### 12.7.4 콜백 함수
- 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수

### 고차함수
- 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수
- 중첩 함수처럼 헬퍼 함수의 역할을 하지만 중첩 함수와 달리 **자유롭게 교체할 수 있다**
- 콜백 함수를 자신의 일부분으로 합성한다.

### 12.7.5 순수 함수와 비순수 함수
### 순수함수
- 어떤 외부 상태에 의존하지도 않고 변경하지도 않는, 부수 효과가 없는 함수
### 비순수 함수
- 외부 상태에 의존하거나 외부 상태를 변경하는, 부수 효과가 있는 함수

**함수가 외부 상태를 변경하면 상태 변화를 추적하기 어려워진다. 따라서 함수 외부 상태의 변경을 지양하는 순수 함수를 사용하는 것이 좋다.**

## 함수형 프로그래밍
- 순수 함수와 보조 함수의 조합을 통해 외부 상태를 변경하는 부수 효과를 최소화해서 불변성을 지향하는 프로그래밍 패러다임.
- 로직 내에 존재하는 조건문과 반복문을 제거해서 복잡성을 해결하면, 변수 사용을 억제하거나 생명 주기를 최소화해서 상태 변경을 피해 오류를 최소화하는 것을 목표로 한다.
- 조건문이나 반복문은 로직의 흐름을 이해하기 어렵게 해서 가독성을 해치고, 
- 변수의 값은 누군가에 의해 언제든 변경될 수 있어 오류 발생의 근본적 원인이 될 수 있다.
- 순수 함수를 통해 부수 효과를 최대한 억제해 오류를 피하고 프로그램의 안정성을 높이려는 노력의 일환.