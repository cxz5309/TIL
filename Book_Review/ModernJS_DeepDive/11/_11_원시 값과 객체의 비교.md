# 11 원시 값과 객체의 비교

| 원시 타입                                  | 객체 타입                         |
| ------------------------------------------ | --------------------------------- |
| 변경 불가능한 값                           | 변경 가능한 값                    |
| 변수 할당시 메모리에는 실제 값이 저장된다. | 변수 할당시 참조 값이 저장된다.   |
| 다른 변수에 할당시 값에 의한 전달          | 다른 변수 할당시 참조에 의한 전달 |

## 11.1 원시 값

### 11.1.1 변경 불가능한 값
- 한번 생성된 원시 값은 **읽기 전용 값**으로서 변경할 수 없다.
- 변수가 아닌 값이 변경 불가능하다.

### 변수
- 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름
### 값 
- 변수에 저장된 데이터로써 표현식이 평가되어 생성된 결과

### 상수
- 재할당이 금지된 변수
- 메모리 공간이 필요하므로 변수 안에 포함
- 변수는 재할당으로 통해 값을 교체 할 수 있지만 상수는 단 한번만 할당이 허용된다.

> 상수의 특징
> 1. 선언과 동시에 초기화
> 2. 재할당 금지

### 원시값의 특성 불변성
- 원시값을 할당한 변수에 재할당시 새로운 메모리 공간을 확보하고 재할당한 원시값을 저장한 후, 새롭게 재할당한 원시 값을 가리킨다. 
- 즉, 변수가 참조하던 메모리 공간의 주소가 바뀐다.
- 불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다.

> 재할당 이외에 원시 값인 변수 값을 변경할 수 있다면 발생하는 문제
> - 값의 변경, 즉 상태 변경을 추적하기 어렵게 만든다.
>   - 가장 대표적으로 전역변수의 남용 상황이 있다.

### 11.1.2 문자열과 불변성

ES 사양 문자열 타입(2바이트)과 숫자 타입(8바이트) 이외의 원시 타입은 크기를 명확히 규정하고 있지 않다.
-> 브라우저 제조사의 구현에 따라 다르다
문자열은 유사 배열 객체이면서 이터러블이므로 배열과 유사하게 각 문자에 접근할 수 있다.

### 유사 배열 객체
- 마치 배열처럼 인덱스로 프로퍼티 값에 접근 가능하고 length프로퍼티를 갖는 객체이다. 

### 11.1.3 값에 의한 전달
- 변수에 원시 값을 갖는 변수를 할당하면 할당받는 변수에는 할당되는 변수의 원시 값이 값 복사(깊은복사) 된다.
- 값에 의한 전달도 사실은 값을 전달하는 것이 아니라 메모리 주소를 전달한다. 단, 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참고할 수 있다.

> 파이썬과의 차이점
> 파이썬은 변수에 원시 값을 갖는 변수를 할당하는 시점까지는 같은 값을 참조하지만 재할당이 이루어졌을때부터 새로운 메모리 공간에 값을 저장한다.

## 11.2 객체

- 프로퍼티의 개수가 정해져있지 않고 동적으로 추가, 삭제된다. 프로퍼티의 값에도 제약이 없어 원시값처럼 확보해야 할 메모리 공간의 크기를 사전에 정해둘 수 없다. 
- 따라서 관리 방식이 복잡하고 구현 방식이 브라우저마다 다를 수 있다.
- 따라서 객체는 원시 값과 다른 방식으로 동작한다.
- 정해진 객체를 생성하고 프로퍼티를 추가, 삭제할 수 없는 c언어나 자바보다 성능 면에서 떨어진다. 따라서 V8 js 엔진에서는 프로퍼티에 접근하기 위해 동적 탐색 대신 히든클래스 방식을 사용해 C++정도의 성능을 보장하였다. 
>히든 클래스 요약
>- 객체는 반드시 하나의 히든 클래스를 참조한다.
>- 히든 클래스는 각 프로퍼티에 대해 메모리 오프셋을 가지고 있다.
>- 동적으로 새로운 프로퍼티가 만들어질 때, 혹은 기존 프로퍼티가 삭제되거나 기존 프로퍼티의 데이터 타입이 바뀔 때는 신규 히든 클래스가 생성되며, 신규 히든 클래스는 기존 프로퍼티에 대한 정보를 유지하면서 추가적으로 새 프로퍼티의 오프셋을 가지게 된다.

### 11.2.1 변경 가능한 값
- 객체는 변경 가능한 값이다. 따라서 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있다.
- 즉, 재할당 없이 프로퍼티를 동적으로 추가할 수도 있고 프로퍼티 값을 갱신할 수도 있으며 프로퍼티 자체를 삭제할 수도 있다.

객체를 생성하고 관리하는 방식은 **매우 복잡하며 비용이 많이 드는 일이다**  
(크기의 가변성으로 인해 깊은 복사의 메모리 비용 문제가 생긴다.)  
-> **따라서 객체는 변경가능한 값으로 설계되었다.**
### -> 그 단점
- 여러개의 식별자가 하나의 객체를 공유할 수 있다.(참조에 의한 전달)

### 11.2.2 참조에 의한 전달
- 여러개의 식별자가 하나의 객체를 공유할 수 있다.
- 원본 또는 사본 중 어느 한쪽에서 객체를 변경(재할당이 아닌 프로퍼티 값을 변경하거나 추가, 삭제) 하면 서로 영향을 주고받는다.

값에 의한 전달과 참조에 의한 전달은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달한다는 면에서 동일하다.
식별자가 기억하는 메모리 공간에는 **원시값** 이냐 **참조값**이냐의 차이만 있을 뿐이다.

> 값에 의한 호출 참조에 의한 호출  
> 원시 자료형을 사용하는 변수들은 모두 값에 의한 호출 방식을 사용한다.  
> 그러나 값에 의한 호출 방식을 사용하지 않는 Array, Object와 같은 객체들은 함수 내부에서도 원본 변수를 변경시킬 수 있다.

> 일치 비교 연산자(===)의 원시값과 객체의 차이  
> 원시값에서 일치 비교 연산자는 값과 타입이 모두 같으면 같은것으로 취급한다.(동등 비교 연산자(==)는 값만 비교한다.)  
> 그러나 객체(레퍼런스 타입)에 대해서는 동일한 객체 또는 함수에 대한 참조가 있어야 완전히 동일하다.  
> https://cpro95.tistory.com/333  
> 따라서 NAN === NAN 은 FALSE이다.   
> https://stackoverflow.com/questions/10034149/why-is-nan-not-equal-to-nan  

> 배열의 불변성을 지키는 방법  
> for, while문 보다 map, filter등 배열의 내장함수로써 새로운 배열을 만드는 것을 추천한다.

> 객체의 불변성을 지키는 방법  
> Object.assign, Object.freeze  
> freeze는 불변 객체로 만들지만 하지만 객체 내부의 객체(Nested Object)는 지키지 못한다.  
> 그러나 Object.assign과 Object.freeze, 을 사용하여 불변 객체를 만드는 방법은 번거러울 뿐더러 성능상 이슈가 있어서 큰 객체에는 사용하지 않는 것이 좋다.  
> 이런 현상이 발생하는 이유는 객체를 하나의 트리 구조로 봤을 때 최상위 레벨의 속성만 복사를 하는 Object.assign(target, ...sources) 메서드의 동작 방식에 있습니다.  
> 객체 트리의 최말단 노드까지 복사되지 않기 때문에 이러한 복제 방식을 얕은 복제(Shallow Clone)라고 일컽습니다.  

> 말단까지의 깊은 복사 대안  
> JSON.parse(JSON.stringify(obj))  
> Facebook이 제공하는 Immutable.js를 사용하는 방법이 있다.  
> Immutable.js는 List, Stack, Map, OrderedMap, Set, OrderedSet, Record와 같은 영구 불변 (Permit Immutable) 데이터 구조를 제공한다.  
> lodash 라는 외부 라이브러리의 cloneDeep(obj)이라는 메서드를 사용. 

