# 15 블록 레벨 스코프

## 15.1 var 키워드로 선언한 변수의 문제점
1. 변수 중복 선언 허용
   - 중복 선언한 변수는 의도치 않은 값의 변경에도 에러가 발생하지 않는다.
2. 함수 레벨 스코프
   - 함수 레벨 스코프는 전역 변수를 남발할 가능성을 높인다. 이는 다시 의도치 않게 전역 변수가 중복 선언되는 경우를 발생시킨다.
3. 변수 호이스팅
   - 변수 호이스팅은 가독성을 떨어뜨리고, 오류의 여지가 생긴다.

## 15.2 let 키워드
1. 변수 중복 선언시 SyntaxError 발생
2. 블록 레벨 스코프
3. 변수 호이스팅이 발생하지 **않는 것처럼 동작한다.**
  - var 키워드로 선언한 변수는 암묵적으로 **선언 단계와 초기화 단계가 한번에 진행된다.** 즉 할당하기 이전에도 호출이 가능하지만 undefined를 반한다.
  - let 키워드로 선언한 변수는 **선언 단계와 초기화 단계가 분리되어 진행된다.** 초기화 단계 이전에 변수에 접근하려고 하면 참조 에러가 발생한다. 
  - 이 스코프의 시작 지점부터 초기화 단계 시작 지점까지 변수를 참조할 수 없는 구간을 일시적 사각지대(tdz)라고 부른다.
> - let 키워드는 변수 호이스팅이 발생하지 않는 것처럼 보이지만 **여전히 호이스팅을 발생시키고 단지 에러를 발생시킨다.**

> 21.4.3 암묵적 전역
```
var x = 10;
function foo(){
  y = 20;
}
foo();
console.log(x + y)
```  
참조 에러가 발생하지 않고 30이 출력된다!  
- **선언하지 않은 식별자는 선언된 전역 변수처럼 동작한다!**
- 이러한 현상을 **암묵적 전역** 이라고 한다.
- 그러나 y는 변수 선언 없이 전역 객체의 프로퍼티로 추가되었을 뿐이며 y는 변수가 아니다! y는 변수가 아니므로 변수 호이스팅이 발생하지 않는다!

### 15.2.4 전역 객체와 let
- **let 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다!** 즉, window.foo와 같이 접근할 수 없다.
- let 전역 변수는 보이지 않는 개념적인 블록 내에 존재하게 된다.
> 23.6.2 전역 코드 평가
- 렉시컬 환경은 2개의 컴포넌트, 즉 환경 레코드와 외부 렉시컬 환경에 대한 참조로 구성된다.
- 전역 렉시컬 환경을 구성하는 컴포넌트인 전역 환경 레코드는 es6 이전까지는 전역 객체(window)가 전역 환경 레코드의 역할을 수행했다. 그러나 es6의 let, const 키워드의 도입부터 var 키워드로 선언한 전역 변수와 let, const키워드로 선언한 전역 변수를 구분하여 관리하기 위해 전역 환경 레코드는 **객체 환경 레코드**와 **선언적 환경 레코드**로 구성되었다.
  - **객체 환경 레코드**는 기존의 전역 객체가 관리하던 var 키워드로 선언한 전역 변수와 함수 선언문으로 정의한 전역 함수를 관리한다.
  - **선언적 환경 레코드**는 let, const 키워드로 선언한 전역 변수를 관리한다.

## 15.3 const 키워드
- const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야 한다.
- 재할당이 금지된다.
- **상수는 상태 유지와 가독성, 유지보수의 편의를 위해 적극적으로 사용된다!**
- **const 키워드로 선언된 변수에 객체가 할당된 경우 값을 변경할 수 있다!**  
- 재할당을 금지할 뿐 프로퍼티 동적 생성, 프로퍼티 값 변경 등의 객체 변경은 가능하다