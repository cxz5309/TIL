# 다익스트라(Dijkstra)

- 다이나믹 프로그래밍(dp)을 활용한 그래프에서의 최단 경로 탐색 알고리즘이다. 
- 하나의 정점에서(a) 다른 모든 정점(b, ...)으로 가는 최단 경로를 알 수 있다. 
- **이때 음의 간선은 포함할 수 없다** 음의 간선을 포함하는 알고리즘으로는 벨만-포드 알고리즘과 <a href='../플로이드&워셜/README.MD'>플로이드-워셜</a> 알고리즘을 사용할 수 있다.
- 음의 간선은 현실세계에서 쉽게 보기 힘들기 때문에 다익스트라 알고리즘이 현실에 자주 적용되는 편이다.
- 다익스트라 알고리즘을 조금 더 현실세계에 맞게 확장시킨 방법으로 A* 알고리즘과 D* 알고리즘이 있다. 대부분의 네비게이션 서비스의 알고리즘은 D* 알고리즘을 사용한다고 한다.

## 작동 방식
다익스트라의 기본은 시작 노드(a)에서 다음 노드(b)까지의 간선의 값을 저장하고, 새로운 값이 들어오게 되면 갱신하는 것이다.(동적 계획법(dp)를 사용하게 된다.)

1. 시작 노드(a)에서 다음 노드(b)까지 이동 할 때의 가중치가 존재한다면 그 값을 dp에 저장한다.
2. 그리고 다음 노드(b)에서 그 다음 노드(c)로 이동이 가능할 때 a->c의 값을 (만약 a->c가 있었다면) a->b->c의 값으로 (비교 후 조건부로)갱신하는 것이다.   
   - `즉 a->c의 가중치가 5이고, a->b의 가중치가 1, b->c의 가중치가 2일 때 a->b->c의 가중치는 3이 되므로 a->c의 가중치를 갱신해주게 된다.`
3. 조건에 따라 다르지만 최저비용에서는 초기값이 infinity로 가 되어야 더 낮은 가중치로 갱신할 수 있다. 전부 갱신 후에도 남아있는 infinity값은 당연히 a가 한번도 방문한 적 없는 노드가 된다.  
   
```
const dijkstra = (graph, start) => {
    let dist = Array(graph.length + 1).fill(Infinity);
    let visited = [];
    dist[start] = 0;
    while (true) {
        let minDist = Infinity;
        let idx = -1;
        for (let i = 0; i < graph.length; i++) {
            if (dist[i] < minDist && !visited[i]) {
                minDist = dist[i];
                idx = i;
            }
        }
        if (idx === -1) return dist;
        for (let i = 0; i < graph[idx].length; i++) {
            if (graph[idx][i] !== 0 && dist[i] > dist[idx] + graph[idx][i]) {
                dist[i] = dist[idx] + graph[idx][i];
            }
        }
        visited[idx] = true;
    }
}
```

### 우선순위 큐를 이용한 방법
- 기본 방식에 비해 <a href='../우선순위 큐//README.MD'>우선순위 큐(min heap)</a> 구조를 사용하여 시간을 단축시킬 수 있다.
- 일반 다익스트라에서는 가장 최단 거리를 가진 정점을 찾기위해 선형 탐색을 이용하지만, MinHeap을 이용하면 log|V|만에 최솟값이 가장 위로 올라오도록 정렬되기에 V * V -> V * log|V|만큼의 큰 시간복잡도를 감소시킬 수 있게 된다.

## 시간복잡도
처음 고안된 알고리즘은 O(V^2)의 시간복잡도를 가졌다. 이후 우선순위 큐(=힙 트리)등을 이용한 더욱 개선된 알고리즘이 나오며, O((V+E)logV)의 시간복잡도를 가지게 되었다.