# 위상 정렬(Topological Sort)

- **사이클이 없는**, **방향 그래프** 에서 사용할 수 있는 정렬 방법이다.
- 사이클이 발생할 경우 위상 정렬을 수행할 수 없다.
  - 사이클이 발생할 경우에는 위상 정렬의 시작점을 찾을 수가 없기 때문, 위상 정렬의 시작은 항상 부모 노드가 없는 최상단 부모 노드여야 한다.
- 위상 정렬 알고리즘은 두가지의 해결책을 준다.
  1. 현재 그래프가 위상 정렬이 가능한지(사이클이 없는 방향 그래프(DAG) 여부)
  2. 위상 정렬의 결과값
## DAG
- 사이클이 없는 방향 그래프는 Directed Acyclic Graph(DAG) 라고 한다.
## DFS 스패닝 트리
- 또한 DAG 에서 DFS를 실행할 경우 방문순서에 따라서 스패닝 트리를 얻을 수 있다.
- 이러한 스패닝 트리를 DFS 스패닝 트리라고 하며 4가지 종류의 간선이 생긴다.
  1. 트리 간선 -> 스패닝 트리에 포함된 간선
  2. 순방향 간선-> 스패닝 트리에는 포함되지 않았지만 선조에서 자손으로 이어지는 간선 
  3. 역방향 간선-> 자손에서 선조로 이어지는 간선
  4. 교차 간선 -> 위 세 경우가 아닌 간선 

## 위상 정렬 구현 방법
1. DFS와 스택을 이용하는 방법
2. 큐를 이용하는 방법

### DFS와 스택을 이용하는 방법
- DFS를 실행하면서 DFS가 끝나는 순서대로 스택에 넣어준다.
- 스택에 쌓이는 순서대로 위상정렬의 결과값이 된다.

<br>

#### 만약 사이클이 생긴다면 어떻게 될까?
![image](https://t1.daumcdn.net/cfile/tistory/210AAB4A5881AF1734)

위상 정렬이 되지 않도록 사이클 간선을 추가한 그래프이다.  
1부터 시작한 dfs는 2로 돌아와 2 -> 5 -> 7 -> 2로 2를 2번 밟게 된다.  
이렇게 같은 정점을 2번 밟게 되는 경우가 바로 사이클이 생기는 경우이므로 바로 return 해주게 된다.

```js
const DFS = (now)=>{
  visited[now] = true;
  for(let next of now.next){
    if(!visited[next])
      DFS(next);
    else if(!finish[next])
      return false;
  }
  finish[now] = true;
  stack.push(now):
}
```


### 큐를 이용하는 방법

- indegree란 한 정점에서 자신에게 들어오는 방향인 간선의 수이다.
- 각 정점에서의 indegree의 개수를 먼저 구한다.
- queue에 indegree가 0인 정점을 삽입한다.
  - indegree가 0인 정점만이 끝점이 될 수 있다. 왜냐하면 indegree가 0이어야만 자식노드가 더이상 없는 자식 노드이기 때문이다.
- 정점의 횟수 만큼 반복문을 돌려 다음 작업을 반복한다.
  - 큐의 front를 추출하여 해당 정점에서 나가는 간선을 다 지워준 후 지워진 간선에 의하여 indegree가 0이 되는 정점들을 queue에 삽입한다. (이때 간선을 지워준 다는 것은 간선의 종점인 정점들의 indegree의 개수를 -1 해줌으로 구현한다.)
#### 만약 사이클이 생긴다면 어떻게 될까?

정점의 횟수만큼 반복문을 돌리던 중 큐의 크기가 먼저 0이 되어 버린다면 사이클이 존재하므로 위상 정렬이 불가능하다는 결론이 나온다.  
사이클에 속하는 정점들이 존재한다면 그 정점들은 모두 indegree가 1이상이라 큐에 들어가지 않기 때문이다.  

```js
for (int i = 1; i <= n; i++) {
  if (!in[i])
    pq.push(-i);
}
while (pq.size()) {
  let now = -pq[pq.length]
  pq.pop();
  console.log(now);
  for(let next of now.next){
    in[next]--;
    if (!in[next])
      pq.push(-next);
  }
}
```

- 위상 정렬의 시간 복잡도는 O(V + E) 이다. 정점의 개수 + 간선의 개수만큼 소요되는 매우 빠른 알고리즘이다.
- 