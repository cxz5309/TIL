# NEXT.js
- React의 SSR(Server Side Rendering)을 쉽게 구현할 수 있게 도와주는 간단한 프레임워크

## SSR(Server Side Rendering)
- 페이지에 대한 요청이 들어오면, 서버에서 렌더링을 마치고 데이터와 결합된 완성된 정적 HTML 파일을 내려준다. 
- 사용자가 다른 페이지에 접근하면 서버는 또 다시 새로운 HTML 파일을 생성하고, 클라이언트에 내려준다. 
- 각 페이지에 접근할 때마다 페이지 전체에서 새로고침이 발생하면서 매번 페이지 갱신이 이루어지기 때문에 비효율적이지만, 페이지가 처음 그려질 때부터 완성된 HTML로 넘어오기 때문에 크롤링을 고려한 SEO(검색 엔진 최적화)에서는 강점이 있다.

## CSR(Client Side Rendering)
- 서버에서는 페이지를 구성하기 위한 최소 리소스만 전달하고, 클라이언트에서 페이지 컨텐츠를 구성하는 방식
- CSR 방식에서는 초기 렌더링 시에 필요한 모든 리소스들을 모두 내려받고 나면, 그 이후부터는 사용자가 접근한 페이지들에서 요청하는 일부 데이터만을 요청하기 때문에 따라서 초기 로딩 속도는 느리지만 불필요한 페이지 갱신과 데이터 요청을 줄일 수 있다는 점에서 큰 장점을 가진다.

## SPA(Single Page Application)
> - SPA 구현을 쉽게 말하면 jsp파일 없이 index.html파일 하나에서 js, css등 리소스 파일들과 모듈들을 로드해서 페이지 이동 없이 특정영역만 새로 모듈을 호출하고 데이터를 바인딩하는 개념
- CSR을 응용하여 현재의 웹개발의 트렌드가 되었다.
- 초기의 SPA 개념인 Backbone.js, Angular.js 라이브러리들을 넘어 지금은 템플릿 개념을 지나 컴포넌트 개념인 React.js, Vue.js, Angular2 등 이렇게 다양한 라이브러리와 프레임워크가 SPA를 지향하고 있다.
- 대표적인 라이브러리/프론트프레임워크 React, Vue/Angular가 있다.
- 기존의 서버 측 렌더링 응용 프로그램과 비교할 때 매우 간단하게 배포 할 수 있다. 
- 실제로는 CSS bundle과 Javascript 번들이 포함 된 index.html 파일이 하나뿐이며, 이 정적 파일들은 은 Apache, Nginx, Amazon S3 또는 Firebase Hosting과 같은 정적 컨텐츠 서버에 업로드 할 수 있다.

### SPA의 단점
- SPA에는 많은 장점이 있지만 공용 인터넷에서 더 큰 규모로 채택되지 않은 이유도 있다.
1. 검색 엔진 최적화(SEO)
  - 비교적 최근까지도 Google과 같은 검색 엔진은 SPA를 올바르게 색인화하는 데 어려움을 겪었으며, Google 검색이 일반적으로 Ajax를 크롤링 할 수 있다는 정보를 가지고 있지만 아직 완전히 수행 할 수 없다는 일부 보고서가 있다.
2. 초기 구동에 시간이 걸림
   - SPA 어프리케이션은 실제 서버에서 HTML을 거의 로드하지 않고 어플리케이션 시작시에 데이터만 네트워크를 통해 전달되기 때문에 성능 향상에 도움을 주지만 모든 데이터를 초기 구동에 가져오기 때문에 첫 구동에 시간이 걸린다.
    - 그러나 이에 대한 기술적 대안도 지속적으로 발전중이며 초기 페이지에서 모든 리소스를 다운받지 않고, 리소스를 청크(Chunk) 단위로 묶어서 해당 리소스에 대한 요청이 있을 때만 다운로드 받도록 하는 방법을 적용하는데 많은 자바스크립트 모듈 번들러에서 Lazy Loading 혹은 비동기 모듈로딩이라는 이름으로 이런 시나리오를 지원하고 있다.


## Next.js 등장 배경
- CSR방식의 React만으로 애플리케이션을 구성하는 데에는 아래와 같은 문제가 있을 수 있다.  
> - 자바스크립트 코드를 번들링 하기 위해 webpack 등의 모듈 번들러를 사용하지만, 그렇게 생성된 자바스크립트 번들은 용량이 크고 그만큼의 로딩 시간이 든다. 최적화를 위해서는 코드 스플리팅 처리가 필요하다.\
> - SEO를 고려하기 위해 자바스크립트 소스를 렌더링하기 전에 정적 소스를 먼저 불러와야 할 경우가 있을 수 있다.  
> - React를 사용하는 경우 SSR 처리가 어렵다.  

- Next.js는 클라이언트 사이드 렌더링에서 발생하는 여러 문제들을 해결하고, React에서 SSR을 구현할 수 있게 해 준다. 
- 이는 서버사이드 렌더링과 클라이언트 사이드 렌더링을 적절히 조합한 것으로 두 방식의 장점을 모두 가진다. 
- 첫 접속은 서버사이드 렌더링으로 이뤄지되, 그 이후에는 클라이언트 사이드 렌더링을 사용하는 것이다.
> 따라서 Next.js는 SSR과 CSR의 단점을 모두 보완한 프레임워크로 그 단점에 반대되는 장점을 가진다.
> - 첫 접속 시, 필요한 페이지의 내용만 받기 때문에 로딩이 빠르다.
> - 검색엔진에 검색되기 용이하다.
> - 페이지 이동이 빠르다.
> - 전체적으로 개별적인 상황에 맞춰 데이터를 수신하기 때문에 속도가 빠르다.

## Next.js의 특징
1. pre-rendering
   - Next.js는 렌더링 서버를 자체적으로 지원하고, 기본적으로 모든 페이지를 프리 렌더링한다. 클라이언트 사이드에서 모든 작업을 수행하는 대신 미리 각 페이지에 대해서 HTML 파일을 미리 만들어 성능과 SEO 측면에서 도움을 준다.
   - Next.js는 최소한의 자바스크립트 코드를 사용해 HTML 화면을 먼저 생성한다. 그리고 이어 자바스크립트가 로드되면, 그때 컴포넌트와 앱 화면이 완전히 활성화된다. 이러한 과정을 hydration이라고 한다.
     - ### Hybrid - SSG and SSR
     - Next.js는 두 가지 형태의 프리 렌더링을 지원한다. 정적 생성(Static Generation)과 서버 사이드 렌더링(SSR)이다. Next.js에서는 성능상의 이유로 SSG를 추천하고 있지만, 각 페이지마다 어떤 종류를 택할지 선택할 수 있다.
       - Static Generation: 빌드 시점에 HTML 파일이 생성되며, 매 요청마다 재사용된다. CDN으로 캐싱되어 사용할 수 있다. 마케팅 이벤트 페이지나 documentation 등, request를 받기 전에 그릴 수 있는 정적 페이지에 사용된다.
       - Server Side Rendering: HTML이 request에 따라 생성된다. 최신화된 데이터를 사용하거나 사용자 요청에 따라 데이터를 받아와야 하는 페이지에서 사용된다.
2. data fetching
   - Next.js에서는 프리 렌더링 단계에서의 data fetching을 위해 아래 세 함수를 지원한다.
   > 1. getStaticProps : 빌드 타임에 데이터 요청
   > 2. getServerSideProps : 매 요청에 따라 데이터 요청
   > 3. getStaticPaths : 요청된 데이터에 의한 다이나믹 라우팅을 명시
3. File system Routes / Dynamic Routes
   - Next.js에서 라우팅 처리되는 컴포넌트들은 최상위에 있는 pages라는 폴더 안에 위치한다.
   - 라우팅은 기본적으로 해당 페이지의 디렉토리 경로에 맞게 호출된다. 만약 라우트가 /authors/me라면, pages/authors 폴더 안에 me.js 파일이 있어야 한다.
   - 동적 라우팅도 사용 가능하다. 변수 파라미터를 표시하기 위해 브라켓 파라메터를 사용한다.

4. Image Optimization
   - next 10.0 버전 이후부터는 html의 `<img>` 태그를 확장한 next/image라는 컴포넌트를 사용할 수 있다. 
   - next/image는 이미지 최적화 기능을 내장하고 있어 리사이징, 옵티마이징, 그리고 WebP와 같은 최신 포맷이 사용 가능한 브라우저에서는 이러한 포맷으로 이미지를 제공한다. 
   - 이미지 옵티마이징을 할 때 빌드되는 시점이 아니라 사용자에 의해 리소스가 요청되는 시점에 실행하기 때문에, 이미지가 많다고 해도 최적화에 따른 빌드 타임이 증가하지 않는다. 
   - 또한 레이지 로딩 기능도 내장하고 있어, viewport 바깥 영역에 있는 이미지들은 스크롤로 화면에 표시될 때만 로드된다.